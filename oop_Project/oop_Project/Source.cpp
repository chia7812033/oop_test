#include <stdio.h>
#include <stdlib.h>
#include <SDL.h>
#include <SDL2_gfxPrimitives.h>
#include <math.h>
#include "SDL_image.h"

const int WIDTH = 800;
const int HEIGHT = 600;
const int mc_FRAME = 4;

struct ImageData
{
	char path[100];
	SDL_Texture *texture;
	int width;
	int height;
};

struct Character
{
	int x_pos;
	int y_pos;
	int x_velo;
	int y_velo;
	int velocity;
	int health;
	int damage;
	int way = 0;  //0 for right, 1 for left
	int action_flag[5] = { 0 }; //0 for stand, 1 for run
};
struct Character main_ch;

int initSDL(); // Starts up SDL and creates window
void closeSDL(); // Frees media and shuts down SDL
ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b);
void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int cx, int cy, double angle, SDL_RendererFlip flip);
void bg_imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY);
void mc_imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, SDL_RendererFlip flip);
void handleEvent(SDL_Event& e);
void move();
Uint32  mc_action(Uint32 interval, void *param);


SDL_Window* window = NULL; // The window we'll be rendering to
SDL_Renderer *renderer = NULL; // The renderer contained by the window

SDL_Texture *bgTexture = NULL; // The background texture
// SDL_Texture *pikaTexture = NULL;
// SDL_Texture *spTexture = NULL;

int initSDL()
{
	// Initialize SDL	
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
	{
		// Error Handling		
		printf("SDL_Init failed: %s\n", SDL_GetError());
		return 1;
	}

	// Create window	
	// SDL_WINDOWPOS_UNDEFINED: Used to indicate that you don't care what the window position is.
	window = SDL_CreateWindow("OOP SDL project", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
	if (window == NULL)
	{
		printf("SDL_CreateWindow failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 2;
	}

	// Create renderer	
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
	if (renderer == NULL)
	{
		SDL_DestroyWindow(window);
		printf("SDL_CreateRenderer failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 3;
	}

	return 0;
}


void closeSDL()
{
	SDL_DestroyTexture(bgTexture);
	// Destroy renderer	
	// Destroy window	
	// Quit SDL subsystems
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	SDL_Quit();
}

ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b)
{
	ImageData img;

	//Load image at specified path
	SDL_Surface* loadedSurface = IMG_Load(path);
	if (loadedSurface == NULL)
	{
		printf("IMG_Load failed: %s\n", IMG_GetError());
	}
	else
	{
		// Set the color key (transparent pixel) in a surface.
		// https://wiki.libsdl.org/SDL_SetColorKey
		// The color key defines a pixel value that will be treated as transparent in a blit. 
		// It is a pixel of the format used by the surface, as generated by SDL_MapRGB().
		// Use SDL_MapRGB() to map an RGB triple to an opaque pixel value for a given pixel format.
		// https://wiki.libsdl.org/SDL_MapRGB
		SDL_SetColorKey(loadedSurface, ckEnable, SDL_MapRGB(loadedSurface->format, r, g, b));

		// Create texture from surface pixels
		img.texture = SDL_CreateTextureFromSurface(renderer, loadedSurface);
		if (img.texture == NULL)
		{
			printf("SDL_CreateTextureFromSurface failed: %s\n", SDL_GetError());
		}

		//Get image dimensions
		img.width = loadedSurface->w;
		img.height = loadedSurface->h;

		// Get rid of old loaded surface
		SDL_FreeSurface(loadedSurface);
	}

	//return newTexture;
	return img;
}


void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int cx, int cy, double angle, SDL_RendererFlip flip)
{
	SDL_Rect r;
	r.x = posX;
	r.y = posY;
	r.w = img.width;
	r.h = img.height;

	SDL_Point center = { cx, cy };
	SDL_RenderCopyEx(renderer, img.texture, NULL, &r, angle, &center, flip);
}

void bg_imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY)
{
	SDL_Rect r;
	r.x = posX;
	r.y = posY;
	r.w = WIDTH;
	r.h = HEIGHT;
	SDL_RenderCopy(renderer, img.texture, NULL, &r);
}

void mc_imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, SDL_RendererFlip flip)
{
	SDL_Rect r;
	r.x = posX;
	r.y = posY;
	r.w = 170;
	r.h = 200;
	SDL_RenderCopyEx(renderer, img.texture, NULL, &r, 0, NULL, flip);
}

void handleEvent(SDL_Event& e)
{
	/* The method for "Debunce" */
	double ratio;
	// If a key was pressed
	// repeat: non-zero if this is a key repeat
	// https://wiki.libsdl.org/SDL_KeyboardEvent
	if (e.type == SDL_KEYDOWN && e.key.repeat == 0)
	{
		static int lasttime = SDL_GetTicks();
		static int curtime = SDL_GetTicks();
		int timediv;
		int time_flag;

		lasttime = curtime;
		curtime = SDL_GetTicks();
		timediv = curtime - lasttime;
		if (timediv < 300)
			time_flag = 1;
		else
			time_flag = 0;
		if (time_flag)
			ratio = 1.35;
		else
			ratio = 1;
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
		case SDLK_a:
			main_ch.action_flag[2] = 1;
			printf("punch\n");
			break;
		case SDLK_UP: 
			if (time_flag)
				main_ch.action_flag[1] = 1;
			else
				main_ch.action_flag[0] = 1;
			main_ch.y_velo -= (int)main_ch.velocity * ratio;
			break;
		case SDLK_DOWN: 
			if (time_flag)
				main_ch.action_flag[1] = 1;
			else
				main_ch.action_flag[0] = 1;
			main_ch.y_velo += (int)main_ch.velocity * ratio;
			break;
		case SDLK_LEFT:
			if (time_flag)
				main_ch.action_flag[1] = 1;
			else
				main_ch.action_flag[0] = 1;
			main_ch.x_velo -= (int)main_ch.velocity * ratio;
			main_ch.way = 1;
			break;
		case SDLK_RIGHT: 
			if (time_flag)
				main_ch.action_flag[1] = 1;
			else
				main_ch.action_flag[0] = 1;
			main_ch.x_velo += (int)main_ch.velocity * ratio;
			main_ch.way = 0;
			break;
		default:
			break;
		}
	}
	//If a key was released
	else if (e.type == SDL_KEYUP && e.key.repeat == 0)
	{
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
		case SDLK_UP: 
			// main_cha.y_velo += (int)main_cha.velocity;
			main_ch.y_velo = 0;
			main_ch.action_flag[0] = 0;
			main_ch.action_flag[1] = 0;
			break;
		case SDLK_DOWN: 
			// main_cha.y_velo -= (int)main_cha.velocity;
			main_ch.y_velo = 0;
			main_ch.action_flag[0] = 0;
			main_ch.action_flag[1] = 0;
			break;
		case SDLK_LEFT: 
			// main_cha.x_velo += (int)main_cha.velocity;
			main_ch.x_velo = 0;
			main_ch.action_flag[0] = 0;
			main_ch.action_flag[1] = 0;
			break;
		case SDLK_RIGHT: 
			// main_cha.x_velo -= (int)main_cha.velocity;
			main_ch.x_velo = 0;
			main_ch.action_flag[0] = 0;
			main_ch.action_flag[1] = 0;
			break;
		default:
			break;
		}
	}
}

void move()
{
	//Move the dot left or right
	main_ch.x_pos += main_ch.x_velo;

	//If the dot went too far to the left or right
	if ((main_ch.x_pos <= 0) || (main_ch.x_pos >= WIDTH - 150))
	{
		//Move back
		main_ch.x_pos -= main_ch.x_velo;
	}

	//Move the dot up or down
	main_ch.y_pos += main_ch.y_velo;

	//If the dot went too far up or down
	if ((main_ch.y_pos <= 0) || (main_ch.y_pos >= HEIGHT -200))
	{
		//Move back
		main_ch.y_pos -= main_ch.y_velo;
	}
}

Uint32  mc_action(Uint32 interval, void *param)
{
	int *index = (int *)param;
	(*index) = ((*index) + 1) % mc_FRAME;

	return interval;
}

int main(int argc, char* args[])
{
	// path for background
	char imgPath_bg[100] = "../images/bg.png";
	char mc_stand_Path[100] = "../images/purple/stand/";
	char mc_walk_Path[100] = "../images/purple/walk/";
	char mc_run_Path[100] = "../images/purple/run/";
	char mc_attack1_Path[100] = "../images/purple/attack1/";

	int mc_stand_index = 0;
	int mc_walk_index = 0;
	int mc_run_index = 0;
	int mc_attack1_index = 0;

	ImageData bg, mc_stand[mc_FRAME], mc_walk[mc_FRAME], mc_run[mc_FRAME], mc_attack1[mc_FRAME];
	

	// Flip type
	SDL_RendererFlip no = SDL_FLIP_NONE;
	SDL_RendererFlip ho = SDL_FLIP_HORIZONTAL;
	SDL_RendererFlip ve = SDL_FLIP_VERTICAL;
	SDL_RendererFlip hove = (SDL_RendererFlip)(SDL_FLIP_HORIZONTAL | SDL_FLIP_VERTICAL);
	SDL_RendererFlip flip_flag;

	// Start up SDL and create window
	if (initSDL())
	{
		printf("Failed to initialize SDL!\n");
		return -1;
	}

	SDL_Event e;

	bg = loadTexture(imgPath_bg, false, 0xFF, 0xFF, 0xFF);

	//load png for main character standing
	for (int i = 0; i < mc_FRAME; i++)
	{
		char str[100];
		sprintf_s(str, 100, "%s%02d.png", mc_stand_Path, i + 1);
		mc_stand[i] = loadTexture(str, false, 0xFF, 0xFF, 0xFF);
	}


	//load png for main character walking
	for (int i = 0; i < mc_FRAME; i++)
	{
		char str[100];
		sprintf_s(str, 100, "%s%02d.png", mc_walk_Path, i + 1);
		mc_walk[i] = loadTexture(str, false, 0xFF, 0xFF, 0xFF);
	}

	//load png for main character running
	for (int i = 0; i < mc_FRAME; i++)
	{
		char str[100];
		sprintf_s(str, 100, "%s%02d.png", mc_run_Path, i + 1);
		mc_run[i] = loadTexture(str, false, 0xFF, 0xFF, 0xFF);
	}

	//load png for main character attack1
	for (int i = 0; i < mc_FRAME - 1; i++)
	{
		char str[100];
		sprintf_s(str, 100, "%s%02d.png", mc_attack1_Path, i + 1);
		mc_attack1[i] = loadTexture(str, false, 0xFF, 0xFF, 0xFF);
	}


	SDL_TimerID mc_timerID1_stand = SDL_AddTimer(100, mc_action, &mc_stand_index);
	SDL_TimerID mc_timerID3_walk = SDL_AddTimer(100, mc_action, &mc_walk_index);
	SDL_TimerID mc_timerID3_run = SDL_AddTimer(100, mc_action, &mc_run_index);

	// initialize main character
	main_ch.x_pos = 100;
	main_ch.y_pos = HEIGHT / 2;
	main_ch.x_velo = 0;
	main_ch.y_velo = 0;
	main_ch.velocity = 2;

	//Main loop flag
	bool quit = false;

	while (!quit)
	{
		// Handle events on queue		
		while (SDL_PollEvent(&e) != 0)
		{
			// User requests quit
			if (e.type == SDL_QUIT)
			{
				quit = true; 
			}

			// Handle input for the dot
			handleEvent(e);
		}

		move();
		// Clear screen
		SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);
		SDL_RenderClear(renderer);

		bg_imgRender(renderer, bg, 0, 0);
		if (main_ch.way)
			flip_flag = ho;
		else
			flip_flag = no;
		
		if (main_ch.action_flag[0]) {
			mc_imgRender(renderer, mc_walk[mc_walk_index], main_ch.x_pos, main_ch.y_pos, flip_flag);
		}
		else if (main_ch.action_flag[1]) {
			mc_imgRender(renderer, mc_run[mc_run_index], main_ch.x_pos, main_ch.y_pos, flip_flag);
		}
		else if (main_ch.action_flag[2]) {
			mc_imgRender(renderer, mc_attack1[0], main_ch.x_pos, main_ch.y_pos, flip_flag);
			main_ch.action_flag[2] = 0;
		}
		else {
			mc_imgRender(renderer, mc_stand[mc_stand_index], main_ch.x_pos, main_ch.y_pos, flip_flag);
		}
		printf("%d %d\n", main_ch.action_flag[0], main_ch.action_flag[1]);
		SDL_RenderPresent(renderer);
	}


	//Free resources and close SDL
	closeSDL();

	return 0;
}